// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/jp-ryuji/go-sample/internal/ent/car"
	"github.com/jp-ryuji/go-sample/internal/ent/caroption"
	"github.com/jp-ryuji/go-sample/internal/ent/company"
	"github.com/jp-ryuji/go-sample/internal/ent/individual"
	"github.com/jp-ryuji/go-sample/internal/ent/predicate"
	"github.com/jp-ryuji/go-sample/internal/ent/rental"
	"github.com/jp-ryuji/go-sample/internal/ent/rentaloption"
	"github.com/jp-ryuji/go-sample/internal/ent/renter"
	"github.com/jp-ryuji/go-sample/internal/ent/tenant"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCar          = "Car"
	TypeCarOption    = "CarOption"
	TypeCompany      = "Company"
	TypeIndividual   = "Individual"
	TypeRental       = "Rental"
	TypeRentalOption = "RentalOption"
	TypeRenter       = "Renter"
	TypeTenant       = "Tenant"
)

// CarMutation represents an operation that mutates the Car nodes in the graph.
type CarMutation struct {
	config
	op             Op
	typ            string
	id             *string
	model          *string
	clearedFields  map[string]struct{}
	tenant         *string
	clearedtenant  bool
	rentals        map[string]struct{}
	removedrentals map[string]struct{}
	clearedrentals bool
	done           bool
	oldValue       func(context.Context) (*Car, error)
	predicates     []predicate.Car
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows management of the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for the Car entity.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the ID field of the mutation.
func withCarID(id string) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Car entities.
func (m *CarMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Car.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModel sets the "model" field.
func (m *CarMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *CarMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *CarMutation) ResetModel() {
	m.model = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *CarMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[car.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRentalIDs adds the "rentals" edge to the Rental entity by ids.
func (m *CarMutation) AddRentalIDs(ids ...string) {
	if m.rentals == nil {
		m.rentals = make(map[string]struct{})
	}
	for i := range ids {
		m.rentals[ids[i]] = struct{}{}
	}
}

// ClearRentals clears the "rentals" edge to the Rental entity.
func (m *CarMutation) ClearRentals() {
	m.clearedrentals = true
}

// RentalsCleared reports if the "rentals" edge to the Rental entity was cleared.
func (m *CarMutation) RentalsCleared() bool {
	return m.clearedrentals
}

// RemoveRentalIDs removes the "rentals" edge to the Rental entity by IDs.
func (m *CarMutation) RemoveRentalIDs(ids ...string) {
	if m.removedrentals == nil {
		m.removedrentals = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rentals, ids[i])
		m.removedrentals[ids[i]] = struct{}{}
	}
}

// RemovedRentals returns the removed IDs of the "rentals" edge to the Rental entity.
func (m *CarMutation) RemovedRentalsIDs() (ids []string) {
	for id := range m.removedrentals {
		ids = append(ids, id)
	}
	return
}

// RentalsIDs returns the "rentals" edge IDs in the mutation.
func (m *CarMutation) RentalsIDs() (ids []string) {
	for id := range m.rentals {
		ids = append(ids, id)
	}
	return
}

// ResetRentals resets all changes to the "rentals" edge.
func (m *CarMutation) ResetRentals() {
	m.rentals = nil
	m.clearedrentals = false
	m.removedrentals = nil
}

// Where appends a list predicates to the CarMutation builder.
func (m *CarMutation) Where(ps ...predicate.Car) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Car, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.model != nil {
		fields = append(fields, car.FieldModel)
	}
	if m.tenant != nil {
		fields = append(fields, car.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case car.FieldModel:
		return m.Model()
	case car.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case car.FieldModel:
		return m.OldModel(ctx)
	case car.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case car.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case car.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	switch name {
	case car.FieldModel:
		m.ResetModel()
		return nil
	case car.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, car.EdgeTenant)
	}
	if m.rentals != nil {
		edges = append(edges, car.EdgeRentals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeRentals:
		ids := make([]ent.Value, 0, len(m.rentals))
		for id := range m.rentals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrentals != nil {
		edges = append(edges, car.EdgeRentals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeRentals:
		ids := make([]ent.Value, 0, len(m.removedrentals))
		for id := range m.removedrentals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, car.EdgeTenant)
	}
	if m.clearedrentals {
		edges = append(edges, car.EdgeRentals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	switch name {
	case car.EdgeTenant:
		return m.clearedtenant
	case car.EdgeRentals:
		return m.clearedrentals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	switch name {
	case car.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	switch name {
	case car.EdgeTenant:
		m.ResetTenant()
		return nil
	case car.EdgeRentals:
		m.ResetRentals()
		return nil
	}
	return fmt.Errorf("unknown Car edge %s", name)
}

// CarOptionMutation represents an operation that mutates the CarOption nodes in the graph.
type CarOptionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	clearedFields         map[string]struct{}
	tenant                *string
	clearedtenant         bool
	rental_options        map[string]struct{}
	removedrental_options map[string]struct{}
	clearedrental_options bool
	done                  bool
	oldValue              func(context.Context) (*CarOption, error)
	predicates            []predicate.CarOption
}

var _ ent.Mutation = (*CarOptionMutation)(nil)

// caroptionOption allows management of the mutation configuration using functional options.
type caroptionOption func(*CarOptionMutation)

// newCarOptionMutation creates new mutation for the CarOption entity.
func newCarOptionMutation(c config, op Op, opts ...caroptionOption) *CarOptionMutation {
	m := &CarOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeCarOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarOptionID sets the ID field of the mutation.
func withCarOptionID(id string) caroptionOption {
	return func(m *CarOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *CarOption
		)
		m.oldValue = func(ctx context.Context) (*CarOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarOption sets the old CarOption of the mutation.
func withCarOption(node *CarOption) caroptionOption {
	return func(m *CarOptionMutation) {
		m.oldValue = func(context.Context) (*CarOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarOption entities.
func (m *CarOptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarOptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarOptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CarOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CarOption entity.
// If the CarOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarOptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarOptionMutation) ResetName() {
	m.name = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *CarOptionMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarOptionMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarOption entity.
// If the CarOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarOptionMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarOptionMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarOptionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[caroption.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarOptionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarOptionMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarOptionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRentalOptionIDs adds the "rental_options" edge to the RentalOption entity by ids.
func (m *CarOptionMutation) AddRentalOptionIDs(ids ...string) {
	if m.rental_options == nil {
		m.rental_options = make(map[string]struct{})
	}
	for i := range ids {
		m.rental_options[ids[i]] = struct{}{}
	}
}

// ClearRentalOptions clears the "rental_options" edge to the RentalOption entity.
func (m *CarOptionMutation) ClearRentalOptions() {
	m.clearedrental_options = true
}

// RentalOptionsCleared reports if the "rental_options" edge to the RentalOption entity was cleared.
func (m *CarOptionMutation) RentalOptionsCleared() bool {
	return m.clearedrental_options
}

// RemoveRentalOptionIDs removes the "rental_options" edge to the RentalOption entity by IDs.
func (m *CarOptionMutation) RemoveRentalOptionIDs(ids ...string) {
	if m.removedrental_options == nil {
		m.removedrental_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rental_options, ids[i])
		m.removedrental_options[ids[i]] = struct{}{}
	}
}

// RemovedRentalOptions returns the removed IDs of the "rental_options" edge to the RentalOption entity.
func (m *CarOptionMutation) RemovedRentalOptionsIDs() (ids []string) {
	for id := range m.removedrental_options {
		ids = append(ids, id)
	}
	return
}

// RentalOptionsIDs returns the "rental_options" edge IDs in the mutation.
func (m *CarOptionMutation) RentalOptionsIDs() (ids []string) {
	for id := range m.rental_options {
		ids = append(ids, id)
	}
	return
}

// ResetRentalOptions resets all changes to the "rental_options" edge.
func (m *CarOptionMutation) ResetRentalOptions() {
	m.rental_options = nil
	m.clearedrental_options = false
	m.removedrental_options = nil
}

// Where appends a list predicates to the CarOptionMutation builder.
func (m *CarOptionMutation) Where(ps ...predicate.CarOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarOption).
func (m *CarOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarOptionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, caroption.FieldName)
	}
	if m.tenant != nil {
		fields = append(fields, caroption.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case caroption.FieldName:
		return m.Name()
	case caroption.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case caroption.FieldName:
		return m.OldName(ctx)
	case caroption.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown CarOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case caroption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case caroption.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CarOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarOptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarOptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarOptionMutation) ResetField(name string) error {
	switch name {
	case caroption.FieldName:
		m.ResetName()
		return nil
	case caroption.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown CarOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, caroption.EdgeTenant)
	}
	if m.rental_options != nil {
		edges = append(edges, caroption.EdgeRentalOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case caroption.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case caroption.EdgeRentalOptions:
		ids := make([]ent.Value, 0, len(m.rental_options))
		for id := range m.rental_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrental_options != nil {
		edges = append(edges, caroption.EdgeRentalOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case caroption.EdgeRentalOptions:
		ids := make([]ent.Value, 0, len(m.removedrental_options))
		for id := range m.removedrental_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, caroption.EdgeTenant)
	}
	if m.clearedrental_options {
		edges = append(edges, caroption.EdgeRentalOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case caroption.EdgeTenant:
		return m.clearedtenant
	case caroption.EdgeRentalOptions:
		return m.clearedrental_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarOptionMutation) ClearEdge(name string) error {
	switch name {
	case caroption.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown CarOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarOptionMutation) ResetEdge(name string) error {
	switch name {
	case caroption.EdgeTenant:
		m.ResetTenant()
		return nil
	case caroption.EdgeRentalOptions:
		m.ResetRentalOptions()
		return nil
	}
	return fmt.Errorf("unknown CarOption edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	company_size   *string
	clearedFields  map[string]struct{}
	tenant         *string
	clearedtenant  bool
	renters        map[string]struct{}
	removedrenters map[string]struct{}
	clearedrenters bool
	done           bool
	oldValue       func(context.Context) (*Company, error)
	predicates     []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id string) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Company entities.
func (m *CompanyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetCompanySize sets the "company_size" field.
func (m *CompanyMutation) SetCompanySize(s string) {
	m.company_size = &s
}

// CompanySize returns the value of the "company_size" field in the mutation.
func (m *CompanyMutation) CompanySize() (r string, exists bool) {
	v := m.company_size
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanySize returns the old "company_size" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldCompanySize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanySize: %w", err)
	}
	return oldValue.CompanySize, nil
}

// ClearCompanySize clears the value of the "company_size" field.
func (m *CompanyMutation) ClearCompanySize() {
	m.company_size = nil
	m.clearedFields[company.FieldCompanySize] = struct{}{}
}

// CompanySizeCleared returns if the "company_size" field was cleared in this mutation.
func (m *CompanyMutation) CompanySizeCleared() bool {
	_, ok := m.clearedFields[company.FieldCompanySize]
	return ok
}

// ResetCompanySize resets all changes to the "company_size" field.
func (m *CompanyMutation) ResetCompanySize() {
	m.company_size = nil
	delete(m.clearedFields, company.FieldCompanySize)
}

// SetTenantID sets the "tenant_id" field.
func (m *CompanyMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CompanyMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CompanyMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CompanyMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[company.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CompanyMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CompanyMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRenterIDs adds the "renters" edge to the Renter entity by ids.
func (m *CompanyMutation) AddRenterIDs(ids ...string) {
	if m.renters == nil {
		m.renters = make(map[string]struct{})
	}
	for i := range ids {
		m.renters[ids[i]] = struct{}{}
	}
}

// ClearRenters clears the "renters" edge to the Renter entity.
func (m *CompanyMutation) ClearRenters() {
	m.clearedrenters = true
}

// RentersCleared reports if the "renters" edge to the Renter entity was cleared.
func (m *CompanyMutation) RentersCleared() bool {
	return m.clearedrenters
}

// RemoveRenterIDs removes the "renters" edge to the Renter entity by IDs.
func (m *CompanyMutation) RemoveRenterIDs(ids ...string) {
	if m.removedrenters == nil {
		m.removedrenters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.renters, ids[i])
		m.removedrenters[ids[i]] = struct{}{}
	}
}

// RemovedRenters returns the removed IDs of the "renters" edge to the Renter entity.
func (m *CompanyMutation) RemovedRentersIDs() (ids []string) {
	for id := range m.removedrenters {
		ids = append(ids, id)
	}
	return
}

// RentersIDs returns the "renters" edge IDs in the mutation.
func (m *CompanyMutation) RentersIDs() (ids []string) {
	for id := range m.renters {
		ids = append(ids, id)
	}
	return
}

// ResetRenters resets all changes to the "renters" edge.
func (m *CompanyMutation) ResetRenters() {
	m.renters = nil
	m.clearedrenters = false
	m.removedrenters = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.company_size != nil {
		fields = append(fields, company.FieldCompanySize)
	}
	if m.tenant != nil {
		fields = append(fields, company.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	case company.FieldCompanySize:
		return m.CompanySize()
	case company.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldCompanySize:
		return m.OldCompanySize(ctx)
	case company.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldCompanySize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanySize(v)
		return nil
	case company.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldCompanySize) {
		fields = append(fields, company.FieldCompanySize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldCompanySize:
		m.ClearCompanySize()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldCompanySize:
		m.ResetCompanySize()
		return nil
	case company.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, company.EdgeTenant)
	}
	if m.renters != nil {
		edges = append(edges, company.EdgeRenters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case company.EdgeRenters:
		ids := make([]ent.Value, 0, len(m.renters))
		for id := range m.renters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrenters != nil {
		edges = append(edges, company.EdgeRenters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeRenters:
		ids := make([]ent.Value, 0, len(m.removedrenters))
		for id := range m.removedrenters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, company.EdgeTenant)
	}
	if m.clearedrenters {
		edges = append(edges, company.EdgeRenters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeTenant:
		return m.clearedtenant
	case company.EdgeRenters:
		return m.clearedrenters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeTenant:
		m.ResetTenant()
		return nil
	case company.EdgeRenters:
		m.ResetRenters()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// IndividualMutation represents an operation that mutates the Individual nodes in the graph.
type IndividualMutation struct {
	config
	op             Op
	typ            string
	id             *string
	email          *string
	first_name     *string
	last_name      *string
	clearedFields  map[string]struct{}
	tenant         *string
	clearedtenant  bool
	renters        map[string]struct{}
	removedrenters map[string]struct{}
	clearedrenters bool
	done           bool
	oldValue       func(context.Context) (*Individual, error)
	predicates     []predicate.Individual
}

var _ ent.Mutation = (*IndividualMutation)(nil)

// individualOption allows management of the mutation configuration using functional options.
type individualOption func(*IndividualMutation)

// newIndividualMutation creates new mutation for the Individual entity.
func newIndividualMutation(c config, op Op, opts ...individualOption) *IndividualMutation {
	m := &IndividualMutation{
		config:        c,
		op:            op,
		typ:           TypeIndividual,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndividualID sets the ID field of the mutation.
func withIndividualID(id string) individualOption {
	return func(m *IndividualMutation) {
		var (
			err   error
			once  sync.Once
			value *Individual
		)
		m.oldValue = func(ctx context.Context) (*Individual, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Individual.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndividual sets the old Individual of the mutation.
func withIndividual(node *Individual) individualOption {
	return func(m *IndividualMutation) {
		m.oldValue = func(context.Context) (*Individual, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndividualMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndividualMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Individual entities.
func (m *IndividualMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndividualMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndividualMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Individual.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *IndividualMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *IndividualMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Individual entity.
// If the Individual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *IndividualMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *IndividualMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *IndividualMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Individual entity.
// If the Individual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *IndividualMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[individual.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *IndividualMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[individual.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *IndividualMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, individual.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *IndividualMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *IndividualMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Individual entity.
// If the Individual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *IndividualMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[individual.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *IndividualMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[individual.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *IndividualMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, individual.FieldLastName)
}

// SetTenantID sets the "tenant_id" field.
func (m *IndividualMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IndividualMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Individual entity.
// If the Individual object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndividualMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IndividualMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *IndividualMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[individual.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *IndividualMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *IndividualMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *IndividualMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRenterIDs adds the "renters" edge to the Renter entity by ids.
func (m *IndividualMutation) AddRenterIDs(ids ...string) {
	if m.renters == nil {
		m.renters = make(map[string]struct{})
	}
	for i := range ids {
		m.renters[ids[i]] = struct{}{}
	}
}

// ClearRenters clears the "renters" edge to the Renter entity.
func (m *IndividualMutation) ClearRenters() {
	m.clearedrenters = true
}

// RentersCleared reports if the "renters" edge to the Renter entity was cleared.
func (m *IndividualMutation) RentersCleared() bool {
	return m.clearedrenters
}

// RemoveRenterIDs removes the "renters" edge to the Renter entity by IDs.
func (m *IndividualMutation) RemoveRenterIDs(ids ...string) {
	if m.removedrenters == nil {
		m.removedrenters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.renters, ids[i])
		m.removedrenters[ids[i]] = struct{}{}
	}
}

// RemovedRenters returns the removed IDs of the "renters" edge to the Renter entity.
func (m *IndividualMutation) RemovedRentersIDs() (ids []string) {
	for id := range m.removedrenters {
		ids = append(ids, id)
	}
	return
}

// RentersIDs returns the "renters" edge IDs in the mutation.
func (m *IndividualMutation) RentersIDs() (ids []string) {
	for id := range m.renters {
		ids = append(ids, id)
	}
	return
}

// ResetRenters resets all changes to the "renters" edge.
func (m *IndividualMutation) ResetRenters() {
	m.renters = nil
	m.clearedrenters = false
	m.removedrenters = nil
}

// Where appends a list predicates to the IndividualMutation builder.
func (m *IndividualMutation) Where(ps ...predicate.Individual) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndividualMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndividualMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Individual, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndividualMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndividualMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Individual).
func (m *IndividualMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndividualMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, individual.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, individual.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, individual.FieldLastName)
	}
	if m.tenant != nil {
		fields = append(fields, individual.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndividualMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case individual.FieldEmail:
		return m.Email()
	case individual.FieldFirstName:
		return m.FirstName()
	case individual.FieldLastName:
		return m.LastName()
	case individual.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndividualMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case individual.FieldEmail:
		return m.OldEmail(ctx)
	case individual.FieldFirstName:
		return m.OldFirstName(ctx)
	case individual.FieldLastName:
		return m.OldLastName(ctx)
	case individual.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown Individual field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndividualMutation) SetField(name string, value ent.Value) error {
	switch name {
	case individual.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case individual.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case individual.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case individual.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Individual field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndividualMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndividualMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndividualMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Individual numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndividualMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(individual.FieldFirstName) {
		fields = append(fields, individual.FieldFirstName)
	}
	if m.FieldCleared(individual.FieldLastName) {
		fields = append(fields, individual.FieldLastName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndividualMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndividualMutation) ClearField(name string) error {
	switch name {
	case individual.FieldFirstName:
		m.ClearFirstName()
		return nil
	case individual.FieldLastName:
		m.ClearLastName()
		return nil
	}
	return fmt.Errorf("unknown Individual nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndividualMutation) ResetField(name string) error {
	switch name {
	case individual.FieldEmail:
		m.ResetEmail()
		return nil
	case individual.FieldFirstName:
		m.ResetFirstName()
		return nil
	case individual.FieldLastName:
		m.ResetLastName()
		return nil
	case individual.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown Individual field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndividualMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, individual.EdgeTenant)
	}
	if m.renters != nil {
		edges = append(edges, individual.EdgeRenters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndividualMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case individual.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case individual.EdgeRenters:
		ids := make([]ent.Value, 0, len(m.renters))
		for id := range m.renters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndividualMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrenters != nil {
		edges = append(edges, individual.EdgeRenters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndividualMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case individual.EdgeRenters:
		ids := make([]ent.Value, 0, len(m.removedrenters))
		for id := range m.removedrenters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndividualMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, individual.EdgeTenant)
	}
	if m.clearedrenters {
		edges = append(edges, individual.EdgeRenters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndividualMutation) EdgeCleared(name string) bool {
	switch name {
	case individual.EdgeTenant:
		return m.clearedtenant
	case individual.EdgeRenters:
		return m.clearedrenters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndividualMutation) ClearEdge(name string) error {
	switch name {
	case individual.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Individual unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndividualMutation) ResetEdge(name string) error {
	switch name {
	case individual.EdgeTenant:
		m.ResetTenant()
		return nil
	case individual.EdgeRenters:
		m.ResetRenters()
		return nil
	}
	return fmt.Errorf("unknown Individual edge %s", name)
}

// RentalMutation represents an operation that mutates the Rental nodes in the graph.
type RentalMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	starts_at             *time.Time
	ends_at               *time.Time
	clearedFields         map[string]struct{}
	tenant                *string
	clearedtenant         bool
	car                   *string
	clearedcar            bool
	renter                *string
	clearedrenter         bool
	rental_options        map[string]struct{}
	removedrental_options map[string]struct{}
	clearedrental_options bool
	done                  bool
	oldValue              func(context.Context) (*Rental, error)
	predicates            []predicate.Rental
}

var _ ent.Mutation = (*RentalMutation)(nil)

// rentalOption allows management of the mutation configuration using functional options.
type rentalOption func(*RentalMutation)

// newRentalMutation creates new mutation for the Rental entity.
func newRentalMutation(c config, op Op, opts ...rentalOption) *RentalMutation {
	m := &RentalMutation{
		config:        c,
		op:            op,
		typ:           TypeRental,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRentalID sets the ID field of the mutation.
func withRentalID(id string) rentalOption {
	return func(m *RentalMutation) {
		var (
			err   error
			once  sync.Once
			value *Rental
		)
		m.oldValue = func(ctx context.Context) (*Rental, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rental.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRental sets the old Rental of the mutation.
func withRental(node *Rental) rentalOption {
	return func(m *RentalMutation) {
		m.oldValue = func(context.Context) (*Rental, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RentalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RentalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rental entities.
func (m *RentalMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RentalMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RentalMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rental.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStartsAt sets the "starts_at" field.
func (m *RentalMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *RentalMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Rental entity.
// If the Rental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *RentalMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetEndsAt sets the "ends_at" field.
func (m *RentalMutation) SetEndsAt(t time.Time) {
	m.ends_at = &t
}

// EndsAt returns the value of the "ends_at" field in the mutation.
func (m *RentalMutation) EndsAt() (r time.Time, exists bool) {
	v := m.ends_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndsAt returns the old "ends_at" field's value of the Rental entity.
// If the Rental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalMutation) OldEndsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndsAt: %w", err)
	}
	return oldValue.EndsAt, nil
}

// ResetEndsAt resets all changes to the "ends_at" field.
func (m *RentalMutation) ResetEndsAt() {
	m.ends_at = nil
}

// SetCarID sets the "car_id" field.
func (m *RentalMutation) SetCarID(s string) {
	m.car = &s
}

// CarID returns the value of the "car_id" field in the mutation.
func (m *RentalMutation) CarID() (r string, exists bool) {
	v := m.car
	if v == nil {
		return
	}
	return *v, true
}

// OldCarID returns the old "car_id" field's value of the Rental entity.
// If the Rental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalMutation) OldCarID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarID: %w", err)
	}
	return oldValue.CarID, nil
}

// ResetCarID resets all changes to the "car_id" field.
func (m *RentalMutation) ResetCarID() {
	m.car = nil
}

// SetRenterID sets the "renter_id" field.
func (m *RentalMutation) SetRenterID(s string) {
	m.renter = &s
}

// RenterID returns the value of the "renter_id" field in the mutation.
func (m *RentalMutation) RenterID() (r string, exists bool) {
	v := m.renter
	if v == nil {
		return
	}
	return *v, true
}

// OldRenterID returns the old "renter_id" field's value of the Rental entity.
// If the Rental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalMutation) OldRenterID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenterID: %w", err)
	}
	return oldValue.RenterID, nil
}

// ResetRenterID resets all changes to the "renter_id" field.
func (m *RentalMutation) ResetRenterID() {
	m.renter = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *RentalMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RentalMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Rental entity.
// If the Rental object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RentalMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RentalMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[rental.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RentalMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RentalMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RentalMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearCar clears the "car" edge to the Car entity.
func (m *RentalMutation) ClearCar() {
	m.clearedcar = true
	m.clearedFields[rental.FieldCarID] = struct{}{}
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *RentalMutation) CarCleared() bool {
	return m.clearedcar
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *RentalMutation) CarIDs() (ids []string) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *RentalMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// ClearRenter clears the "renter" edge to the Renter entity.
func (m *RentalMutation) ClearRenter() {
	m.clearedrenter = true
	m.clearedFields[rental.FieldRenterID] = struct{}{}
}

// RenterCleared reports if the "renter" edge to the Renter entity was cleared.
func (m *RentalMutation) RenterCleared() bool {
	return m.clearedrenter
}

// RenterIDs returns the "renter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RenterID instead. It exists only for internal usage by the builders.
func (m *RentalMutation) RenterIDs() (ids []string) {
	if id := m.renter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRenter resets all changes to the "renter" edge.
func (m *RentalMutation) ResetRenter() {
	m.renter = nil
	m.clearedrenter = false
}

// AddRentalOptionIDs adds the "rental_options" edge to the RentalOption entity by ids.
func (m *RentalMutation) AddRentalOptionIDs(ids ...string) {
	if m.rental_options == nil {
		m.rental_options = make(map[string]struct{})
	}
	for i := range ids {
		m.rental_options[ids[i]] = struct{}{}
	}
}

// ClearRentalOptions clears the "rental_options" edge to the RentalOption entity.
func (m *RentalMutation) ClearRentalOptions() {
	m.clearedrental_options = true
}

// RentalOptionsCleared reports if the "rental_options" edge to the RentalOption entity was cleared.
func (m *RentalMutation) RentalOptionsCleared() bool {
	return m.clearedrental_options
}

// RemoveRentalOptionIDs removes the "rental_options" edge to the RentalOption entity by IDs.
func (m *RentalMutation) RemoveRentalOptionIDs(ids ...string) {
	if m.removedrental_options == nil {
		m.removedrental_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rental_options, ids[i])
		m.removedrental_options[ids[i]] = struct{}{}
	}
}

// RemovedRentalOptions returns the removed IDs of the "rental_options" edge to the RentalOption entity.
func (m *RentalMutation) RemovedRentalOptionsIDs() (ids []string) {
	for id := range m.removedrental_options {
		ids = append(ids, id)
	}
	return
}

// RentalOptionsIDs returns the "rental_options" edge IDs in the mutation.
func (m *RentalMutation) RentalOptionsIDs() (ids []string) {
	for id := range m.rental_options {
		ids = append(ids, id)
	}
	return
}

// ResetRentalOptions resets all changes to the "rental_options" edge.
func (m *RentalMutation) ResetRentalOptions() {
	m.rental_options = nil
	m.clearedrental_options = false
	m.removedrental_options = nil
}

// Where appends a list predicates to the RentalMutation builder.
func (m *RentalMutation) Where(ps ...predicate.Rental) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RentalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RentalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rental, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RentalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RentalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rental).
func (m *RentalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RentalMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.starts_at != nil {
		fields = append(fields, rental.FieldStartsAt)
	}
	if m.ends_at != nil {
		fields = append(fields, rental.FieldEndsAt)
	}
	if m.car != nil {
		fields = append(fields, rental.FieldCarID)
	}
	if m.renter != nil {
		fields = append(fields, rental.FieldRenterID)
	}
	if m.tenant != nil {
		fields = append(fields, rental.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RentalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rental.FieldStartsAt:
		return m.StartsAt()
	case rental.FieldEndsAt:
		return m.EndsAt()
	case rental.FieldCarID:
		return m.CarID()
	case rental.FieldRenterID:
		return m.RenterID()
	case rental.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RentalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rental.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case rental.FieldEndsAt:
		return m.OldEndsAt(ctx)
	case rental.FieldCarID:
		return m.OldCarID(ctx)
	case rental.FieldRenterID:
		return m.OldRenterID(ctx)
	case rental.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown Rental field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RentalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rental.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case rental.FieldEndsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndsAt(v)
		return nil
	case rental.FieldCarID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarID(v)
		return nil
	case rental.FieldRenterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenterID(v)
		return nil
	case rental.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Rental field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RentalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RentalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RentalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rental numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RentalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RentalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RentalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rental nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RentalMutation) ResetField(name string) error {
	switch name {
	case rental.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case rental.FieldEndsAt:
		m.ResetEndsAt()
		return nil
	case rental.FieldCarID:
		m.ResetCarID()
		return nil
	case rental.FieldRenterID:
		m.ResetRenterID()
		return nil
	case rental.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown Rental field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RentalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, rental.EdgeTenant)
	}
	if m.car != nil {
		edges = append(edges, rental.EdgeCar)
	}
	if m.renter != nil {
		edges = append(edges, rental.EdgeRenter)
	}
	if m.rental_options != nil {
		edges = append(edges, rental.EdgeRentalOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RentalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rental.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case rental.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case rental.EdgeRenter:
		if id := m.renter; id != nil {
			return []ent.Value{*id}
		}
	case rental.EdgeRentalOptions:
		ids := make([]ent.Value, 0, len(m.rental_options))
		for id := range m.rental_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RentalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrental_options != nil {
		edges = append(edges, rental.EdgeRentalOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RentalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rental.EdgeRentalOptions:
		ids := make([]ent.Value, 0, len(m.removedrental_options))
		for id := range m.removedrental_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RentalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, rental.EdgeTenant)
	}
	if m.clearedcar {
		edges = append(edges, rental.EdgeCar)
	}
	if m.clearedrenter {
		edges = append(edges, rental.EdgeRenter)
	}
	if m.clearedrental_options {
		edges = append(edges, rental.EdgeRentalOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RentalMutation) EdgeCleared(name string) bool {
	switch name {
	case rental.EdgeTenant:
		return m.clearedtenant
	case rental.EdgeCar:
		return m.clearedcar
	case rental.EdgeRenter:
		return m.clearedrenter
	case rental.EdgeRentalOptions:
		return m.clearedrental_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RentalMutation) ClearEdge(name string) error {
	switch name {
	case rental.EdgeTenant:
		m.ClearTenant()
		return nil
	case rental.EdgeCar:
		m.ClearCar()
		return nil
	case rental.EdgeRenter:
		m.ClearRenter()
		return nil
	}
	return fmt.Errorf("unknown Rental unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RentalMutation) ResetEdge(name string) error {
	switch name {
	case rental.EdgeTenant:
		m.ResetTenant()
		return nil
	case rental.EdgeCar:
		m.ResetCar()
		return nil
	case rental.EdgeRenter:
		m.ResetRenter()
		return nil
	case rental.EdgeRentalOptions:
		m.ResetRentalOptions()
		return nil
	}
	return fmt.Errorf("unknown Rental edge %s", name)
}

// RentalOptionMutation represents an operation that mutates the RentalOption nodes in the graph.
type RentalOptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	count         *int
	addcount      *int
	clearedFields map[string]struct{}
	tenant        *string
	clearedtenant bool
	rental        *string
	clearedrental bool
	option        *string
	clearedoption bool
	done          bool
	oldValue      func(context.Context) (*RentalOption, error)
	predicates    []predicate.RentalOption
}

var _ ent.Mutation = (*RentalOptionMutation)(nil)

// rentaloptionOption allows management of the mutation configuration using functional options.
type rentaloptionOption func(*RentalOptionMutation)

// newRentalOptionMutation creates new mutation for the RentalOption entity.
func newRentalOptionMutation(c config, op Op, opts ...rentaloptionOption) *RentalOptionMutation {
	m := &RentalOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeRentalOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRentalOptionID sets the ID field of the mutation.
func withRentalOptionID(id string) rentaloptionOption {
	return func(m *RentalOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *RentalOption
		)
		m.oldValue = func(ctx context.Context) (*RentalOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RentalOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRentalOption sets the old RentalOption of the mutation.
func withRentalOption(node *RentalOption) rentaloptionOption {
	return func(m *RentalOptionMutation) {
		m.oldValue = func(context.Context) (*RentalOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RentalOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RentalOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RentalOption entities.
func (m *RentalOptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RentalOptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RentalOptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RentalOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCount sets the "count" field.
func (m *RentalOptionMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *RentalOptionMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the RentalOption entity.
// If the RentalOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalOptionMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *RentalOptionMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *RentalOptionMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *RentalOptionMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetRentalID sets the "rental_id" field.
func (m *RentalOptionMutation) SetRentalID(s string) {
	m.rental = &s
}

// RentalID returns the value of the "rental_id" field in the mutation.
func (m *RentalOptionMutation) RentalID() (r string, exists bool) {
	v := m.rental
	if v == nil {
		return
	}
	return *v, true
}

// OldRentalID returns the old "rental_id" field's value of the RentalOption entity.
// If the RentalOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalOptionMutation) OldRentalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRentalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRentalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentalID: %w", err)
	}
	return oldValue.RentalID, nil
}

// ResetRentalID resets all changes to the "rental_id" field.
func (m *RentalOptionMutation) ResetRentalID() {
	m.rental = nil
}

// SetOptionID sets the "option_id" field.
func (m *RentalOptionMutation) SetOptionID(s string) {
	m.option = &s
}

// OptionID returns the value of the "option_id" field in the mutation.
func (m *RentalOptionMutation) OptionID() (r string, exists bool) {
	v := m.option
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionID returns the old "option_id" field's value of the RentalOption entity.
// If the RentalOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalOptionMutation) OldOptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionID: %w", err)
	}
	return oldValue.OptionID, nil
}

// ResetOptionID resets all changes to the "option_id" field.
func (m *RentalOptionMutation) ResetOptionID() {
	m.option = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *RentalOptionMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RentalOptionMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the RentalOption entity.
// If the RentalOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RentalOptionMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RentalOptionMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RentalOptionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[rentaloption.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RentalOptionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RentalOptionMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RentalOptionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearRental clears the "rental" edge to the Rental entity.
func (m *RentalOptionMutation) ClearRental() {
	m.clearedrental = true
	m.clearedFields[rentaloption.FieldRentalID] = struct{}{}
}

// RentalCleared reports if the "rental" edge to the Rental entity was cleared.
func (m *RentalOptionMutation) RentalCleared() bool {
	return m.clearedrental
}

// RentalIDs returns the "rental" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RentalID instead. It exists only for internal usage by the builders.
func (m *RentalOptionMutation) RentalIDs() (ids []string) {
	if id := m.rental; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRental resets all changes to the "rental" edge.
func (m *RentalOptionMutation) ResetRental() {
	m.rental = nil
	m.clearedrental = false
}

// ClearOption clears the "option" edge to the CarOption entity.
func (m *RentalOptionMutation) ClearOption() {
	m.clearedoption = true
	m.clearedFields[rentaloption.FieldOptionID] = struct{}{}
}

// OptionCleared reports if the "option" edge to the CarOption entity was cleared.
func (m *RentalOptionMutation) OptionCleared() bool {
	return m.clearedoption
}

// OptionIDs returns the "option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OptionID instead. It exists only for internal usage by the builders.
func (m *RentalOptionMutation) OptionIDs() (ids []string) {
	if id := m.option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOption resets all changes to the "option" edge.
func (m *RentalOptionMutation) ResetOption() {
	m.option = nil
	m.clearedoption = false
}

// Where appends a list predicates to the RentalOptionMutation builder.
func (m *RentalOptionMutation) Where(ps ...predicate.RentalOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RentalOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RentalOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RentalOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RentalOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RentalOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RentalOption).
func (m *RentalOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RentalOptionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.count != nil {
		fields = append(fields, rentaloption.FieldCount)
	}
	if m.rental != nil {
		fields = append(fields, rentaloption.FieldRentalID)
	}
	if m.option != nil {
		fields = append(fields, rentaloption.FieldOptionID)
	}
	if m.tenant != nil {
		fields = append(fields, rentaloption.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RentalOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rentaloption.FieldCount:
		return m.Count()
	case rentaloption.FieldRentalID:
		return m.RentalID()
	case rentaloption.FieldOptionID:
		return m.OptionID()
	case rentaloption.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RentalOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rentaloption.FieldCount:
		return m.OldCount(ctx)
	case rentaloption.FieldRentalID:
		return m.OldRentalID(ctx)
	case rentaloption.FieldOptionID:
		return m.OldOptionID(ctx)
	case rentaloption.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown RentalOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RentalOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rentaloption.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case rentaloption.FieldRentalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentalID(v)
		return nil
	case rentaloption.FieldOptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionID(v)
		return nil
	case rentaloption.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown RentalOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RentalOptionMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, rentaloption.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RentalOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rentaloption.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RentalOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rentaloption.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown RentalOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RentalOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RentalOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RentalOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RentalOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RentalOptionMutation) ResetField(name string) error {
	switch name {
	case rentaloption.FieldCount:
		m.ResetCount()
		return nil
	case rentaloption.FieldRentalID:
		m.ResetRentalID()
		return nil
	case rentaloption.FieldOptionID:
		m.ResetOptionID()
		return nil
	case rentaloption.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown RentalOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RentalOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, rentaloption.EdgeTenant)
	}
	if m.rental != nil {
		edges = append(edges, rentaloption.EdgeRental)
	}
	if m.option != nil {
		edges = append(edges, rentaloption.EdgeOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RentalOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rentaloption.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case rentaloption.EdgeRental:
		if id := m.rental; id != nil {
			return []ent.Value{*id}
		}
	case rentaloption.EdgeOption:
		if id := m.option; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RentalOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RentalOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RentalOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, rentaloption.EdgeTenant)
	}
	if m.clearedrental {
		edges = append(edges, rentaloption.EdgeRental)
	}
	if m.clearedoption {
		edges = append(edges, rentaloption.EdgeOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RentalOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case rentaloption.EdgeTenant:
		return m.clearedtenant
	case rentaloption.EdgeRental:
		return m.clearedrental
	case rentaloption.EdgeOption:
		return m.clearedoption
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RentalOptionMutation) ClearEdge(name string) error {
	switch name {
	case rentaloption.EdgeTenant:
		m.ClearTenant()
		return nil
	case rentaloption.EdgeRental:
		m.ClearRental()
		return nil
	case rentaloption.EdgeOption:
		m.ClearOption()
		return nil
	}
	return fmt.Errorf("unknown RentalOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RentalOptionMutation) ResetEdge(name string) error {
	switch name {
	case rentaloption.EdgeTenant:
		m.ResetTenant()
		return nil
	case rentaloption.EdgeRental:
		m.ResetRental()
		return nil
	case rentaloption.EdgeOption:
		m.ResetOption()
		return nil
	}
	return fmt.Errorf("unknown RentalOption edge %s", name)
}

// RenterMutation represents an operation that mutates the Renter nodes in the graph.
type RenterMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	renter_entity_type *string
	clearedFields      map[string]struct{}
	tenant             *string
	clearedtenant      bool
	rentals            map[string]struct{}
	removedrentals     map[string]struct{}
	clearedrentals     bool
	company            *string
	clearedcompany     bool
	individual         *string
	clearedindividual  bool
	done               bool
	oldValue           func(context.Context) (*Renter, error)
	predicates         []predicate.Renter
}

var _ ent.Mutation = (*RenterMutation)(nil)

// renterOption allows management of the mutation configuration using functional options.
type renterOption func(*RenterMutation)

// newRenterMutation creates new mutation for the Renter entity.
func newRenterMutation(c config, op Op, opts ...renterOption) *RenterMutation {
	m := &RenterMutation{
		config:        c,
		op:            op,
		typ:           TypeRenter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRenterID sets the ID field of the mutation.
func withRenterID(id string) renterOption {
	return func(m *RenterMutation) {
		var (
			err   error
			once  sync.Once
			value *Renter
		)
		m.oldValue = func(ctx context.Context) (*Renter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Renter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRenter sets the old Renter of the mutation.
func withRenter(node *Renter) renterOption {
	return func(m *RenterMutation) {
		m.oldValue = func(context.Context) (*Renter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RenterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RenterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Renter entities.
func (m *RenterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RenterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RenterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Renter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRenterEntityID sets the "renter_entity_id" field.
func (m *RenterMutation) SetRenterEntityID(s string) {
	m.individual = &s
}

// RenterEntityID returns the value of the "renter_entity_id" field in the mutation.
func (m *RenterMutation) RenterEntityID() (r string, exists bool) {
	v := m.individual
	if v == nil {
		return
	}
	return *v, true
}

// OldRenterEntityID returns the old "renter_entity_id" field's value of the Renter entity.
// If the Renter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenterMutation) OldRenterEntityID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenterEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenterEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenterEntityID: %w", err)
	}
	return oldValue.RenterEntityID, nil
}

// ClearRenterEntityID clears the value of the "renter_entity_id" field.
func (m *RenterMutation) ClearRenterEntityID() {
	m.individual = nil
	m.clearedFields[renter.FieldRenterEntityID] = struct{}{}
}

// RenterEntityIDCleared returns if the "renter_entity_id" field was cleared in this mutation.
func (m *RenterMutation) RenterEntityIDCleared() bool {
	_, ok := m.clearedFields[renter.FieldRenterEntityID]
	return ok
}

// ResetRenterEntityID resets all changes to the "renter_entity_id" field.
func (m *RenterMutation) ResetRenterEntityID() {
	m.individual = nil
	delete(m.clearedFields, renter.FieldRenterEntityID)
}

// SetRenterEntityType sets the "renter_entity_type" field.
func (m *RenterMutation) SetRenterEntityType(s string) {
	m.renter_entity_type = &s
}

// RenterEntityType returns the value of the "renter_entity_type" field in the mutation.
func (m *RenterMutation) RenterEntityType() (r string, exists bool) {
	v := m.renter_entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRenterEntityType returns the old "renter_entity_type" field's value of the Renter entity.
// If the Renter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenterMutation) OldRenterEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenterEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenterEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenterEntityType: %w", err)
	}
	return oldValue.RenterEntityType, nil
}

// ClearRenterEntityType clears the value of the "renter_entity_type" field.
func (m *RenterMutation) ClearRenterEntityType() {
	m.renter_entity_type = nil
	m.clearedFields[renter.FieldRenterEntityType] = struct{}{}
}

// RenterEntityTypeCleared returns if the "renter_entity_type" field was cleared in this mutation.
func (m *RenterMutation) RenterEntityTypeCleared() bool {
	_, ok := m.clearedFields[renter.FieldRenterEntityType]
	return ok
}

// ResetRenterEntityType resets all changes to the "renter_entity_type" field.
func (m *RenterMutation) ResetRenterEntityType() {
	m.renter_entity_type = nil
	delete(m.clearedFields, renter.FieldRenterEntityType)
}

// SetTenantID sets the "tenant_id" field.
func (m *RenterMutation) SetTenantID(s string) {
	m.tenant = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *RenterMutation) TenantID() (r string, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Renter entity.
// If the Renter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RenterMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *RenterMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *RenterMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[renter.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *RenterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *RenterMutation) TenantIDs() (ids []string) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *RenterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRentalIDs adds the "rentals" edge to the Rental entity by ids.
func (m *RenterMutation) AddRentalIDs(ids ...string) {
	if m.rentals == nil {
		m.rentals = make(map[string]struct{})
	}
	for i := range ids {
		m.rentals[ids[i]] = struct{}{}
	}
}

// ClearRentals clears the "rentals" edge to the Rental entity.
func (m *RenterMutation) ClearRentals() {
	m.clearedrentals = true
}

// RentalsCleared reports if the "rentals" edge to the Rental entity was cleared.
func (m *RenterMutation) RentalsCleared() bool {
	return m.clearedrentals
}

// RemoveRentalIDs removes the "rentals" edge to the Rental entity by IDs.
func (m *RenterMutation) RemoveRentalIDs(ids ...string) {
	if m.removedrentals == nil {
		m.removedrentals = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rentals, ids[i])
		m.removedrentals[ids[i]] = struct{}{}
	}
}

// RemovedRentals returns the removed IDs of the "rentals" edge to the Rental entity.
func (m *RenterMutation) RemovedRentalsIDs() (ids []string) {
	for id := range m.removedrentals {
		ids = append(ids, id)
	}
	return
}

// RentalsIDs returns the "rentals" edge IDs in the mutation.
func (m *RenterMutation) RentalsIDs() (ids []string) {
	for id := range m.rentals {
		ids = append(ids, id)
	}
	return
}

// ResetRentals resets all changes to the "rentals" edge.
func (m *RenterMutation) ResetRentals() {
	m.rentals = nil
	m.clearedrentals = false
	m.removedrentals = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *RenterMutation) SetCompanyID(id string) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *RenterMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[renter.FieldRenterEntityID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *RenterMutation) CompanyCleared() bool {
	return m.RenterEntityIDCleared() || m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *RenterMutation) CompanyID() (id string, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *RenterMutation) CompanyIDs() (ids []string) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *RenterMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetIndividualID sets the "individual" edge to the Individual entity by id.
func (m *RenterMutation) SetIndividualID(id string) {
	m.individual = &id
}

// ClearIndividual clears the "individual" edge to the Individual entity.
func (m *RenterMutation) ClearIndividual() {
	m.clearedindividual = true
	m.clearedFields[renter.FieldRenterEntityID] = struct{}{}
}

// IndividualCleared reports if the "individual" edge to the Individual entity was cleared.
func (m *RenterMutation) IndividualCleared() bool {
	return m.RenterEntityIDCleared() || m.clearedindividual
}

// IndividualID returns the "individual" edge ID in the mutation.
func (m *RenterMutation) IndividualID() (id string, exists bool) {
	if m.individual != nil {
		return *m.individual, true
	}
	return
}

// IndividualIDs returns the "individual" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndividualID instead. It exists only for internal usage by the builders.
func (m *RenterMutation) IndividualIDs() (ids []string) {
	if id := m.individual; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndividual resets all changes to the "individual" edge.
func (m *RenterMutation) ResetIndividual() {
	m.individual = nil
	m.clearedindividual = false
}

// Where appends a list predicates to the RenterMutation builder.
func (m *RenterMutation) Where(ps ...predicate.Renter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RenterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RenterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Renter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RenterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RenterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Renter).
func (m *RenterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RenterMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.individual != nil {
		fields = append(fields, renter.FieldRenterEntityID)
	}
	if m.renter_entity_type != nil {
		fields = append(fields, renter.FieldRenterEntityType)
	}
	if m.tenant != nil {
		fields = append(fields, renter.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RenterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case renter.FieldRenterEntityID:
		return m.RenterEntityID()
	case renter.FieldRenterEntityType:
		return m.RenterEntityType()
	case renter.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RenterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case renter.FieldRenterEntityID:
		return m.OldRenterEntityID(ctx)
	case renter.FieldRenterEntityType:
		return m.OldRenterEntityType(ctx)
	case renter.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown Renter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case renter.FieldRenterEntityID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenterEntityID(v)
		return nil
	case renter.FieldRenterEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenterEntityType(v)
		return nil
	case renter.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown Renter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RenterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RenterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RenterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Renter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RenterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(renter.FieldRenterEntityID) {
		fields = append(fields, renter.FieldRenterEntityID)
	}
	if m.FieldCleared(renter.FieldRenterEntityType) {
		fields = append(fields, renter.FieldRenterEntityType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RenterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RenterMutation) ClearField(name string) error {
	switch name {
	case renter.FieldRenterEntityID:
		m.ClearRenterEntityID()
		return nil
	case renter.FieldRenterEntityType:
		m.ClearRenterEntityType()
		return nil
	}
	return fmt.Errorf("unknown Renter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RenterMutation) ResetField(name string) error {
	switch name {
	case renter.FieldRenterEntityID:
		m.ResetRenterEntityID()
		return nil
	case renter.FieldRenterEntityType:
		m.ResetRenterEntityType()
		return nil
	case renter.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown Renter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RenterMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, renter.EdgeTenant)
	}
	if m.rentals != nil {
		edges = append(edges, renter.EdgeRentals)
	}
	if m.company != nil {
		edges = append(edges, renter.EdgeCompany)
	}
	if m.individual != nil {
		edges = append(edges, renter.EdgeIndividual)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RenterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case renter.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case renter.EdgeRentals:
		ids := make([]ent.Value, 0, len(m.rentals))
		for id := range m.rentals {
			ids = append(ids, id)
		}
		return ids
	case renter.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case renter.EdgeIndividual:
		if id := m.individual; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RenterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrentals != nil {
		edges = append(edges, renter.EdgeRentals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RenterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case renter.EdgeRentals:
		ids := make([]ent.Value, 0, len(m.removedrentals))
		for id := range m.removedrentals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RenterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, renter.EdgeTenant)
	}
	if m.clearedrentals {
		edges = append(edges, renter.EdgeRentals)
	}
	if m.clearedcompany {
		edges = append(edges, renter.EdgeCompany)
	}
	if m.clearedindividual {
		edges = append(edges, renter.EdgeIndividual)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RenterMutation) EdgeCleared(name string) bool {
	switch name {
	case renter.EdgeTenant:
		return m.clearedtenant
	case renter.EdgeRentals:
		return m.clearedrentals
	case renter.EdgeCompany:
		return m.clearedcompany
	case renter.EdgeIndividual:
		return m.clearedindividual
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RenterMutation) ClearEdge(name string) error {
	switch name {
	case renter.EdgeTenant:
		m.ClearTenant()
		return nil
	case renter.EdgeCompany:
		m.ClearCompany()
		return nil
	case renter.EdgeIndividual:
		m.ClearIndividual()
		return nil
	}
	return fmt.Errorf("unknown Renter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RenterMutation) ResetEdge(name string) error {
	switch name {
	case renter.EdgeTenant:
		m.ResetTenant()
		return nil
	case renter.EdgeRentals:
		m.ResetRentals()
		return nil
	case renter.EdgeCompany:
		m.ResetCompany()
		return nil
	case renter.EdgeIndividual:
		m.ResetIndividual()
		return nil
	}
	return fmt.Errorf("unknown Renter edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *string
	code          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
	predicates    []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id string) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}
