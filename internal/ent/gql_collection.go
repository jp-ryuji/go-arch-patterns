// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/jp-ryuji/go-sample/internal/ent/car"
	"github.com/jp-ryuji/go-sample/internal/ent/caroption"
	"github.com/jp-ryuji/go-sample/internal/ent/company"
	"github.com/jp-ryuji/go-sample/internal/ent/individual"
	"github.com/jp-ryuji/go-sample/internal/ent/rental"
	"github.com/jp-ryuji/go-sample/internal/ent/rentaloption"
	"github.com/jp-ryuji/go-sample/internal/ent/renter"
	"github.com/jp-ryuji/go-sample/internal/ent/tenant"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CarQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CarQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(car.Columns))
		selectedFields = []string{car.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[car.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, car.FieldTenantID)
				fieldSeen[car.FieldTenantID] = struct{}{}
			}

		case "rentals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentals(alias, func(wq *RentalQuery) {
				*wq = *query
			})
		case "model":
			if _, ok := fieldSeen[car.FieldModel]; !ok {
				selectedFields = append(selectedFields, car.FieldModel)
				fieldSeen[car.FieldModel] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[car.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, car.FieldTenantID)
				fieldSeen[car.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type carPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarPaginateOption
}

func newCarPaginateArgs(rv map[string]any) *carPaginateArgs {
	args := &carPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &CarOrder{Field: &CarOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCarOrder(order))
			}
		case *CarOrder:
			if v != nil {
				args.opts = append(args.opts, WithCarOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CarOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CarOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(caroption.Columns))
		selectedFields = []string{caroption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[caroption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, caroption.FieldTenantID)
				fieldSeen[caroption.FieldTenantID] = struct{}{}
			}

		case "rentalOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentaloptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentalOptions(alias, func(wq *RentalOptionQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[caroption.FieldName]; !ok {
				selectedFields = append(selectedFields, caroption.FieldName)
				fieldSeen[caroption.FieldName] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[caroption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, caroption.FieldTenantID)
				fieldSeen[caroption.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type caroptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarOptionPaginateOption
}

func newCarOptionPaginateArgs(rv map[string]any) *caroptionPaginateArgs {
	args := &caroptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &CarOptionOrder{Field: &CarOptionOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCarOptionOrder(order))
			}
		case *CarOptionOrder:
			if v != nil {
				args.opts = append(args.opts, WithCarOptionOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CompanyQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CompanyQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(company.Columns))
		selectedFields = []string{company.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[company.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, company.FieldTenantID)
				fieldSeen[company.FieldTenantID] = struct{}{}
			}

		case "renters":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRenters(alias, func(wq *RenterQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[company.FieldName]; !ok {
				selectedFields = append(selectedFields, company.FieldName)
				fieldSeen[company.FieldName] = struct{}{}
			}
		case "companySize":
			if _, ok := fieldSeen[company.FieldCompanySize]; !ok {
				selectedFields = append(selectedFields, company.FieldCompanySize)
				fieldSeen[company.FieldCompanySize] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[company.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, company.FieldTenantID)
				fieldSeen[company.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type companyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyPaginateOption
}

func newCompanyPaginateArgs(rv map[string]any) *companyPaginateArgs {
	args := &companyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &CompanyOrder{Field: &CompanyOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCompanyOrder(order))
			}
		case *CompanyOrder:
			if v != nil {
				args.opts = append(args.opts, WithCompanyOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *IndividualQuery) CollectFields(ctx context.Context, satisfies ...string) (*IndividualQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *IndividualQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(individual.Columns))
		selectedFields = []string{individual.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[individual.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, individual.FieldTenantID)
				fieldSeen[individual.FieldTenantID] = struct{}{}
			}

		case "renters":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRenters(alias, func(wq *RenterQuery) {
				*wq = *query
			})
		case "email":
			if _, ok := fieldSeen[individual.FieldEmail]; !ok {
				selectedFields = append(selectedFields, individual.FieldEmail)
				fieldSeen[individual.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[individual.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, individual.FieldFirstName)
				fieldSeen[individual.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[individual.FieldLastName]; !ok {
				selectedFields = append(selectedFields, individual.FieldLastName)
				fieldSeen[individual.FieldLastName] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[individual.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, individual.FieldTenantID)
				fieldSeen[individual.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type individualPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IndividualPaginateOption
}

func newIndividualPaginateArgs(rv map[string]any) *individualPaginateArgs {
	args := &individualPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &IndividualOrder{Field: &IndividualOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithIndividualOrder(order))
			}
		case *IndividualOrder:
			if v != nil {
				args.opts = append(args.opts, WithIndividualOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RentalQuery) CollectFields(ctx context.Context, satisfies ...string) (*RentalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RentalQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(rental.Columns))
		selectedFields = []string{rental.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[rental.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rental.FieldTenantID)
				fieldSeen[rental.FieldTenantID] = struct{}{}
			}

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			_q.withCar = query
			if _, ok := fieldSeen[rental.FieldCarID]; !ok {
				selectedFields = append(selectedFields, rental.FieldCarID)
				fieldSeen[rental.FieldCarID] = struct{}{}
			}

		case "renter":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.withRenter = query
			if _, ok := fieldSeen[rental.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, rental.FieldRenterID)
				fieldSeen[rental.FieldRenterID] = struct{}{}
			}

		case "rentalOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentaloptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentalOptions(alias, func(wq *RentalOptionQuery) {
				*wq = *query
			})
		case "startsAt":
			if _, ok := fieldSeen[rental.FieldStartsAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldStartsAt)
				fieldSeen[rental.FieldStartsAt] = struct{}{}
			}
		case "endsAt":
			if _, ok := fieldSeen[rental.FieldEndsAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldEndsAt)
				fieldSeen[rental.FieldEndsAt] = struct{}{}
			}
		case "carID":
			if _, ok := fieldSeen[rental.FieldCarID]; !ok {
				selectedFields = append(selectedFields, rental.FieldCarID)
				fieldSeen[rental.FieldCarID] = struct{}{}
			}
		case "renterID":
			if _, ok := fieldSeen[rental.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, rental.FieldRenterID)
				fieldSeen[rental.FieldRenterID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[rental.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rental.FieldTenantID)
				fieldSeen[rental.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type rentalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RentalPaginateOption
}

func newRentalPaginateArgs(rv map[string]any) *rentalPaginateArgs {
	args := &rentalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &RentalOrder{Field: &RentalOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithRentalOrder(order))
			}
		case *RentalOrder:
			if v != nil {
				args.opts = append(args.opts, WithRentalOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RentalOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*RentalOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RentalOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(rentaloption.Columns))
		selectedFields = []string{rentaloption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[rentaloption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldTenantID)
				fieldSeen[rentaloption.FieldTenantID] = struct{}{}
			}

		case "rental":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.withRental = query
			if _, ok := fieldSeen[rentaloption.FieldRentalID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldRentalID)
				fieldSeen[rentaloption.FieldRentalID] = struct{}{}
			}

		case "option":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, caroptionImplementors)...); err != nil {
				return err
			}
			_q.withOption = query
			if _, ok := fieldSeen[rentaloption.FieldOptionID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldOptionID)
				fieldSeen[rentaloption.FieldOptionID] = struct{}{}
			}
		case "count":
			if _, ok := fieldSeen[rentaloption.FieldCount]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldCount)
				fieldSeen[rentaloption.FieldCount] = struct{}{}
			}
		case "rentalID":
			if _, ok := fieldSeen[rentaloption.FieldRentalID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldRentalID)
				fieldSeen[rentaloption.FieldRentalID] = struct{}{}
			}
		case "optionID":
			if _, ok := fieldSeen[rentaloption.FieldOptionID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldOptionID)
				fieldSeen[rentaloption.FieldOptionID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[rentaloption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldTenantID)
				fieldSeen[rentaloption.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type rentaloptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RentalOptionPaginateOption
}

func newRentalOptionPaginateArgs(rv map[string]any) *rentaloptionPaginateArgs {
	args := &rentaloptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &RentalOptionOrder{Field: &RentalOptionOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithRentalOptionOrder(order))
			}
		case *RentalOptionOrder:
			if v != nil {
				args.opts = append(args.opts, WithRentalOptionOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RenterQuery) CollectFields(ctx context.Context, satisfies ...string) (*RenterQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RenterQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(renter.Columns))
		selectedFields = []string{renter.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[renter.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, renter.FieldTenantID)
				fieldSeen[renter.FieldTenantID] = struct{}{}
			}

		case "rentals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentals(alias, func(wq *RentalQuery) {
				*wq = *query
			})

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyImplementors)...); err != nil {
				return err
			}
			_q.withCompany = query
			if _, ok := fieldSeen[renter.FieldRenterEntityID]; !ok {
				selectedFields = append(selectedFields, renter.FieldRenterEntityID)
				fieldSeen[renter.FieldRenterEntityID] = struct{}{}
			}

		case "individual":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IndividualClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, individualImplementors)...); err != nil {
				return err
			}
			_q.withIndividual = query
			if _, ok := fieldSeen[renter.FieldRenterEntityID]; !ok {
				selectedFields = append(selectedFields, renter.FieldRenterEntityID)
				fieldSeen[renter.FieldRenterEntityID] = struct{}{}
			}
		case "renterEntityID":
			if _, ok := fieldSeen[renter.FieldRenterEntityID]; !ok {
				selectedFields = append(selectedFields, renter.FieldRenterEntityID)
				fieldSeen[renter.FieldRenterEntityID] = struct{}{}
			}
		case "renterEntityType":
			if _, ok := fieldSeen[renter.FieldRenterEntityType]; !ok {
				selectedFields = append(selectedFields, renter.FieldRenterEntityType)
				fieldSeen[renter.FieldRenterEntityType] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[renter.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, renter.FieldTenantID)
				fieldSeen[renter.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type renterPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RenterPaginateOption
}

func newRenterPaginateArgs(rv map[string]any) *renterPaginateArgs {
	args := &renterPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &RenterOrder{Field: &RenterOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithRenterOrder(order))
			}
		case *RenterOrder:
			if v != nil {
				args.opts = append(args.opts, WithRenterOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *TenantQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *TenantQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenant.Columns))
		selectedFields = []string{tenant.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "code":
			if _, ok := fieldSeen[tenant.FieldCode]; !ok {
				selectedFields = append(selectedFields, tenant.FieldCode)
				fieldSeen[tenant.FieldCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type tenantPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantPaginateOption
}

func newTenantPaginateArgs(rv map[string]any) *tenantPaginateArgs {
	args := &tenantPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TenantOrder{Field: &TenantOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTenantOrder(order))
			}
		case *TenantOrder:
			if v != nil {
				args.opts = append(args.opts, WithTenantOrder(v))
			}
		}
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok || v == nil {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
