// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"context"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/car"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/caroption"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/company"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/individual"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/outbox"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/rental"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/rentaloption"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/renter"
	"github.com/jp-ryuji/go-arch-patterns/internal/infrastructure/postgres/entgen/tenant"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CarQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CarQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(car.Columns))
		selectedFields = []string{car.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[car.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, car.FieldTenantID)
				fieldSeen[car.FieldTenantID] = struct{}{}
			}

		case "rentals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentals(alias, func(wq *RentalQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[car.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, car.FieldTenantID)
				fieldSeen[car.FieldTenantID] = struct{}{}
			}
		case "model":
			if _, ok := fieldSeen[car.FieldModel]; !ok {
				selectedFields = append(selectedFields, car.FieldModel)
				fieldSeen[car.FieldModel] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[car.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, car.FieldCreatedAt)
				fieldSeen[car.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[car.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, car.FieldUpdatedAt)
				fieldSeen[car.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type carPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarPaginateOption
}

func newCarPaginateArgs(rv map[string]any) *carPaginateArgs {
	args := &carPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CarOrder:
			args.opts = append(args.opts, WithCarOrder(v))
		case []any:
			var orders []*CarOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CarOrder{Field: &CarOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCarOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CarOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CarOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(caroption.Columns))
		selectedFields = []string{caroption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[caroption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, caroption.FieldTenantID)
				fieldSeen[caroption.FieldTenantID] = struct{}{}
			}

		case "rentalOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentaloptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentalOptions(alias, func(wq *RentalOptionQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[caroption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, caroption.FieldTenantID)
				fieldSeen[caroption.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[caroption.FieldName]; !ok {
				selectedFields = append(selectedFields, caroption.FieldName)
				fieldSeen[caroption.FieldName] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[caroption.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, caroption.FieldCreatedAt)
				fieldSeen[caroption.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[caroption.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, caroption.FieldUpdatedAt)
				fieldSeen[caroption.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type caroptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarOptionPaginateOption
}

func newCarOptionPaginateArgs(rv map[string]any) *caroptionPaginateArgs {
	args := &caroptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CarOptionOrder:
			args.opts = append(args.opts, WithCarOptionOrder(v))
		case []any:
			var orders []*CarOptionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CarOptionOrder{Field: &CarOptionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCarOptionOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *CompanyQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *CompanyQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(company.Columns))
		selectedFields = []string{company.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[company.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, company.FieldTenantID)
				fieldSeen[company.FieldTenantID] = struct{}{}
			}

		case "renter":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.withRenter = query
			if _, ok := fieldSeen[company.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, company.FieldRenterID)
				fieldSeen[company.FieldRenterID] = struct{}{}
			}
		case "renterID":
			if _, ok := fieldSeen[company.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, company.FieldRenterID)
				fieldSeen[company.FieldRenterID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[company.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, company.FieldTenantID)
				fieldSeen[company.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[company.FieldName]; !ok {
				selectedFields = append(selectedFields, company.FieldName)
				fieldSeen[company.FieldName] = struct{}{}
			}
		case "companySize":
			if _, ok := fieldSeen[company.FieldCompanySize]; !ok {
				selectedFields = append(selectedFields, company.FieldCompanySize)
				fieldSeen[company.FieldCompanySize] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[company.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, company.FieldCreatedAt)
				fieldSeen[company.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[company.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, company.FieldUpdatedAt)
				fieldSeen[company.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type companyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyPaginateOption
}

func newCompanyPaginateArgs(rv map[string]any) *companyPaginateArgs {
	args := &companyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*CompanyOrder:
			args.opts = append(args.opts, WithCompanyOrder(v))
		case []any:
			var orders []*CompanyOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &CompanyOrder{Field: &CompanyOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithCompanyOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *IndividualQuery) CollectFields(ctx context.Context, satisfies ...string) (*IndividualQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *IndividualQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(individual.Columns))
		selectedFields = []string{individual.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[individual.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, individual.FieldTenantID)
				fieldSeen[individual.FieldTenantID] = struct{}{}
			}

		case "renter":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.withRenter = query
			if _, ok := fieldSeen[individual.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, individual.FieldRenterID)
				fieldSeen[individual.FieldRenterID] = struct{}{}
			}
		case "renterID":
			if _, ok := fieldSeen[individual.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, individual.FieldRenterID)
				fieldSeen[individual.FieldRenterID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[individual.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, individual.FieldTenantID)
				fieldSeen[individual.FieldTenantID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[individual.FieldEmail]; !ok {
				selectedFields = append(selectedFields, individual.FieldEmail)
				fieldSeen[individual.FieldEmail] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[individual.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, individual.FieldFirstName)
				fieldSeen[individual.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[individual.FieldLastName]; !ok {
				selectedFields = append(selectedFields, individual.FieldLastName)
				fieldSeen[individual.FieldLastName] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[individual.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, individual.FieldCreatedAt)
				fieldSeen[individual.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[individual.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, individual.FieldUpdatedAt)
				fieldSeen[individual.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type individualPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IndividualPaginateOption
}

func newIndividualPaginateArgs(rv map[string]any) *individualPaginateArgs {
	args := &individualPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*IndividualOrder:
			args.opts = append(args.opts, WithIndividualOrder(v))
		case []any:
			var orders []*IndividualOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &IndividualOrder{Field: &IndividualOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithIndividualOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *OutboxQuery) CollectFields(ctx context.Context, satisfies ...string) (*OutboxQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *OutboxQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(outbox.Columns))
		selectedFields = []string{outbox.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "aggregateType":
			if _, ok := fieldSeen[outbox.FieldAggregateType]; !ok {
				selectedFields = append(selectedFields, outbox.FieldAggregateType)
				fieldSeen[outbox.FieldAggregateType] = struct{}{}
			}
		case "aggregateID":
			if _, ok := fieldSeen[outbox.FieldAggregateID]; !ok {
				selectedFields = append(selectedFields, outbox.FieldAggregateID)
				fieldSeen[outbox.FieldAggregateID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[outbox.FieldEventType]; !ok {
				selectedFields = append(selectedFields, outbox.FieldEventType)
				fieldSeen[outbox.FieldEventType] = struct{}{}
			}
		case "payload":
			if _, ok := fieldSeen[outbox.FieldPayload]; !ok {
				selectedFields = append(selectedFields, outbox.FieldPayload)
				fieldSeen[outbox.FieldPayload] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[outbox.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, outbox.FieldCreatedAt)
				fieldSeen[outbox.FieldCreatedAt] = struct{}{}
			}
		case "processedAt":
			if _, ok := fieldSeen[outbox.FieldProcessedAt]; !ok {
				selectedFields = append(selectedFields, outbox.FieldProcessedAt)
				fieldSeen[outbox.FieldProcessedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[outbox.FieldStatus]; !ok {
				selectedFields = append(selectedFields, outbox.FieldStatus)
				fieldSeen[outbox.FieldStatus] = struct{}{}
			}
		case "errorMessage":
			if _, ok := fieldSeen[outbox.FieldErrorMessage]; !ok {
				selectedFields = append(selectedFields, outbox.FieldErrorMessage)
				fieldSeen[outbox.FieldErrorMessage] = struct{}{}
			}
		case "version":
			if _, ok := fieldSeen[outbox.FieldVersion]; !ok {
				selectedFields = append(selectedFields, outbox.FieldVersion)
				fieldSeen[outbox.FieldVersion] = struct{}{}
			}
		case "lockedAt":
			if _, ok := fieldSeen[outbox.FieldLockedAt]; !ok {
				selectedFields = append(selectedFields, outbox.FieldLockedAt)
				fieldSeen[outbox.FieldLockedAt] = struct{}{}
			}
		case "lockedBy":
			if _, ok := fieldSeen[outbox.FieldLockedBy]; !ok {
				selectedFields = append(selectedFields, outbox.FieldLockedBy)
				fieldSeen[outbox.FieldLockedBy] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type outboxPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OutboxPaginateOption
}

func newOutboxPaginateArgs(rv map[string]any) *outboxPaginateArgs {
	args := &outboxPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*OutboxOrder:
			args.opts = append(args.opts, WithOutboxOrder(v))
		case []any:
			var orders []*OutboxOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &OutboxOrder{Field: &OutboxOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithOutboxOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RentalQuery) CollectFields(ctx context.Context, satisfies ...string) (*RentalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RentalQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(rental.Columns))
		selectedFields = []string{rental.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[rental.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rental.FieldTenantID)
				fieldSeen[rental.FieldTenantID] = struct{}{}
			}

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			_q.withCar = query
			if _, ok := fieldSeen[rental.FieldCarID]; !ok {
				selectedFields = append(selectedFields, rental.FieldCarID)
				fieldSeen[rental.FieldCarID] = struct{}{}
			}

		case "renter":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.withRenter = query
			if _, ok := fieldSeen[rental.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, rental.FieldRenterID)
				fieldSeen[rental.FieldRenterID] = struct{}{}
			}

		case "rentalOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentaloptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentalOptions(alias, func(wq *RentalOptionQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[rental.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rental.FieldTenantID)
				fieldSeen[rental.FieldTenantID] = struct{}{}
			}
		case "carID":
			if _, ok := fieldSeen[rental.FieldCarID]; !ok {
				selectedFields = append(selectedFields, rental.FieldCarID)
				fieldSeen[rental.FieldCarID] = struct{}{}
			}
		case "renterID":
			if _, ok := fieldSeen[rental.FieldRenterID]; !ok {
				selectedFields = append(selectedFields, rental.FieldRenterID)
				fieldSeen[rental.FieldRenterID] = struct{}{}
			}
		case "startsAt":
			if _, ok := fieldSeen[rental.FieldStartsAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldStartsAt)
				fieldSeen[rental.FieldStartsAt] = struct{}{}
			}
		case "endsAt":
			if _, ok := fieldSeen[rental.FieldEndsAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldEndsAt)
				fieldSeen[rental.FieldEndsAt] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[rental.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldCreatedAt)
				fieldSeen[rental.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[rental.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, rental.FieldUpdatedAt)
				fieldSeen[rental.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type rentalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RentalPaginateOption
}

func newRentalPaginateArgs(rv map[string]any) *rentalPaginateArgs {
	args := &rentalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*RentalOrder:
			args.opts = append(args.opts, WithRentalOrder(v))
		case []any:
			var orders []*RentalOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &RentalOrder{Field: &RentalOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithRentalOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RentalOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*RentalOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RentalOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(rentaloption.Columns))
		selectedFields = []string{rentaloption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[rentaloption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldTenantID)
				fieldSeen[rentaloption.FieldTenantID] = struct{}{}
			}

		case "rental":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.withRental = query
			if _, ok := fieldSeen[rentaloption.FieldRentalID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldRentalID)
				fieldSeen[rentaloption.FieldRentalID] = struct{}{}
			}

		case "option":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, caroptionImplementors)...); err != nil {
				return err
			}
			_q.withOption = query
			if _, ok := fieldSeen[rentaloption.FieldOptionID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldOptionID)
				fieldSeen[rentaloption.FieldOptionID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[rentaloption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldTenantID)
				fieldSeen[rentaloption.FieldTenantID] = struct{}{}
			}
		case "rentalID":
			if _, ok := fieldSeen[rentaloption.FieldRentalID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldRentalID)
				fieldSeen[rentaloption.FieldRentalID] = struct{}{}
			}
		case "optionID":
			if _, ok := fieldSeen[rentaloption.FieldOptionID]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldOptionID)
				fieldSeen[rentaloption.FieldOptionID] = struct{}{}
			}
		case "count":
			if _, ok := fieldSeen[rentaloption.FieldCount]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldCount)
				fieldSeen[rentaloption.FieldCount] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[rentaloption.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldCreatedAt)
				fieldSeen[rentaloption.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[rentaloption.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, rentaloption.FieldUpdatedAt)
				fieldSeen[rentaloption.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type rentaloptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RentalOptionPaginateOption
}

func newRentalOptionPaginateArgs(rv map[string]any) *rentaloptionPaginateArgs {
	args := &rentaloptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*RentalOptionOrder:
			args.opts = append(args.opts, WithRentalOptionOrder(v))
		case []any:
			var orders []*RentalOptionOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &RentalOptionOrder{Field: &RentalOptionOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithRentalOptionOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *RenterQuery) CollectFields(ctx context.Context, satisfies ...string) (*RenterQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *RenterQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(renter.Columns))
		selectedFields = []string{renter.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			_q.withTenant = query
			if _, ok := fieldSeen[renter.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, renter.FieldTenantID)
				fieldSeen[renter.FieldTenantID] = struct{}{}
			}

		case "rentals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentals(alias, func(wq *RentalQuery) {
				*wq = *query
			})

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyImplementors)...); err != nil {
				return err
			}
			_q.withCompany = query

		case "individual":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IndividualClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, individualImplementors)...); err != nil {
				return err
			}
			_q.withIndividual = query
		case "tenantID":
			if _, ok := fieldSeen[renter.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, renter.FieldTenantID)
				fieldSeen[renter.FieldTenantID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[renter.FieldType]; !ok {
				selectedFields = append(selectedFields, renter.FieldType)
				fieldSeen[renter.FieldType] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[renter.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, renter.FieldCreatedAt)
				fieldSeen[renter.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[renter.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, renter.FieldUpdatedAt)
				fieldSeen[renter.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type renterPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RenterPaginateOption
}

func newRenterPaginateArgs(rv map[string]any) *renterPaginateArgs {
	args := &renterPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*RenterOrder:
			args.opts = append(args.opts, WithRenterOrder(v))
		case []any:
			var orders []*RenterOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &RenterOrder{Field: &RenterOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithRenterOrder(orders))
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (_q *TenantQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return _q, nil
	}
	if err := _q.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return _q, nil
}

func (_q *TenantQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenant.Columns))
		selectedFields = []string{tenant.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "cars":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			_q.WithNamedCars(alias, func(wq *CarQuery) {
				*wq = *query
			})

		case "companies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyImplementors)...); err != nil {
				return err
			}
			_q.WithNamedCompanies(alias, func(wq *CompanyQuery) {
				*wq = *query
			})

		case "individuals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IndividualClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, individualImplementors)...); err != nil {
				return err
			}
			_q.WithNamedIndividuals(alias, func(wq *IndividualQuery) {
				*wq = *query
			})

		case "options":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, caroptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedOptions(alias, func(wq *CarOptionQuery) {
				*wq = *query
			})

		case "rentalOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalOptionClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentaloptionImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentalOptions(alias, func(wq *RentalOptionQuery) {
				*wq = *query
			})

		case "rentals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RentalClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, rentalImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRentals(alias, func(wq *RentalQuery) {
				*wq = *query
			})

		case "renters":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RenterClient{config: _q.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, renterImplementors)...); err != nil {
				return err
			}
			_q.WithNamedRenters(alias, func(wq *RenterQuery) {
				*wq = *query
			})
		case "code":
			if _, ok := fieldSeen[tenant.FieldCode]; !ok {
				selectedFields = append(selectedFields, tenant.FieldCode)
				fieldSeen[tenant.FieldCode] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[tenant.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tenant.FieldCreatedAt)
				fieldSeen[tenant.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tenant.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tenant.FieldUpdatedAt)
				fieldSeen[tenant.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		_q.Select(selectedFields...)
	}
	return nil
}

type tenantPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantPaginateOption
}

func newTenantPaginateArgs(rv map[string]any) *tenantPaginateArgs {
	args := &tenantPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TenantOrder:
			args.opts = append(args.opts, WithTenantOrder(v))
		case []any:
			var orders []*TenantOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TenantOrder{Field: &TenantOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTenantOrder(orders))
		}
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok || v == nil {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
