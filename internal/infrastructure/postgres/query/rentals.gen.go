// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"github.com/jp-ryuji/go-sample/internal/infrastructure/postgres/dbmodel"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newRental(db *gorm.DB, opts ...gen.DOOption) rental {
	_rental := rental{}

	_rental.rentalDo.UseDB(db, opts...)
	_rental.rentalDo.UseModel(&dbmodel.Rental{})

	tableName := _rental.rentalDo.TableName()
	_rental.ALL = field.NewAsterisk(tableName)
	_rental.ID = field.NewString(tableName, "id")
	_rental.TenantID = field.NewString(tableName, "tenant_id")
	_rental.CarID = field.NewString(tableName, "car_id")
	_rental.RenterID = field.NewString(tableName, "renter_id")
	_rental.StartsAt = field.NewTime(tableName, "starts_at")
	_rental.EndsAt = field.NewTime(tableName, "ends_at")
	_rental.CreatedAt = field.NewTime(tableName, "created_at")
	_rental.UpdatedAt = field.NewTime(tableName, "updated_at")
	_rental.DeletedAt = field.NewField(tableName, "deleted_at")
	_rental.RentalOptions = rentalHasManyRentalOptions{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("RentalOptions", "dbmodel.RentalOption"),
		Rental: struct {
			field.RelationField
			Tenant struct {
				field.RelationField
				Cars struct {
					field.RelationField
					Tenant struct {
						field.RelationField
					}
					Rentals struct {
						field.RelationField
					}
				}
			}
			Car struct {
				field.RelationField
			}
			Renter struct {
				field.RelationField
				Rentals struct {
					field.RelationField
				}
			}
			RentalOptions struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("RentalOptions.Rental", "dbmodel.Rental"),
			Tenant: struct {
				field.RelationField
				Cars struct {
					field.RelationField
					Tenant struct {
						field.RelationField
					}
					Rentals struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("RentalOptions.Rental.Tenant", "dbmodel.Tenant"),
				Cars: struct {
					field.RelationField
					Tenant struct {
						field.RelationField
					}
					Rentals struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("RentalOptions.Rental.Tenant.Cars", "dbmodel.Car"),
					Tenant: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("RentalOptions.Rental.Tenant.Cars.Tenant", "dbmodel.Tenant"),
					},
					Rentals: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("RentalOptions.Rental.Tenant.Cars.Rentals", "dbmodel.Rental"),
					},
				},
			},
			Car: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("RentalOptions.Rental.Car", "dbmodel.Car"),
			},
			Renter: struct {
				field.RelationField
				Rentals struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("RentalOptions.Rental.Renter", "dbmodel.Renter"),
				Rentals: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("RentalOptions.Rental.Renter.Rentals", "dbmodel.Rental"),
				},
			},
			RentalOptions: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("RentalOptions.Rental.RentalOptions", "dbmodel.RentalOption"),
			},
		},
		Option: struct {
			field.RelationField
			RentalOptions struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("RentalOptions.Option", "dbmodel.Option"),
			RentalOptions: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("RentalOptions.Option.RentalOptions", "dbmodel.RentalOption"),
			},
		},
	}

	_rental.Tenant = rentalBelongsToTenant{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Tenant", "dbmodel.Tenant"),
	}

	_rental.Car = rentalBelongsToCar{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Car", "dbmodel.Car"),
	}

	_rental.Renter = rentalBelongsToRenter{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Renter", "dbmodel.Renter"),
	}

	_rental.fillFieldMap()

	return _rental
}

type rental struct {
	rentalDo rentalDo

	ALL           field.Asterisk
	ID            field.String
	TenantID      field.String
	CarID         field.String
	RenterID      field.String
	StartsAt      field.Time
	EndsAt        field.Time
	CreatedAt     field.Time
	UpdatedAt     field.Time
	DeletedAt     field.Field
	RentalOptions rentalHasManyRentalOptions

	Tenant rentalBelongsToTenant

	Car rentalBelongsToCar

	Renter rentalBelongsToRenter

	fieldMap map[string]field.Expr
}

func (r rental) Table(newTableName string) *rental {
	r.rentalDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r rental) As(alias string) *rental {
	r.rentalDo.DO = *(r.rentalDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *rental) updateTableName(table string) *rental {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewString(table, "id")
	r.TenantID = field.NewString(table, "tenant_id")
	r.CarID = field.NewString(table, "car_id")
	r.RenterID = field.NewString(table, "renter_id")
	r.StartsAt = field.NewTime(table, "starts_at")
	r.EndsAt = field.NewTime(table, "ends_at")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.UpdatedAt = field.NewTime(table, "updated_at")
	r.DeletedAt = field.NewField(table, "deleted_at")

	r.fillFieldMap()

	return r
}

func (r *rental) WithContext(ctx context.Context) *rentalDo { return r.rentalDo.WithContext(ctx) }

func (r rental) TableName() string { return r.rentalDo.TableName() }

func (r rental) Alias() string { return r.rentalDo.Alias() }

func (r rental) Columns(cols ...field.Expr) gen.Columns { return r.rentalDo.Columns(cols...) }

func (r *rental) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *rental) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 13)
	r.fieldMap["id"] = r.ID
	r.fieldMap["tenant_id"] = r.TenantID
	r.fieldMap["car_id"] = r.CarID
	r.fieldMap["renter_id"] = r.RenterID
	r.fieldMap["starts_at"] = r.StartsAt
	r.fieldMap["ends_at"] = r.EndsAt
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["updated_at"] = r.UpdatedAt
	r.fieldMap["deleted_at"] = r.DeletedAt

}

func (r rental) clone(db *gorm.DB) rental {
	r.rentalDo.ReplaceConnPool(db.Statement.ConnPool)
	r.RentalOptions.db = db.Session(&gorm.Session{Initialized: true})
	r.RentalOptions.db.Statement.ConnPool = db.Statement.ConnPool
	r.Tenant.db = db.Session(&gorm.Session{Initialized: true})
	r.Tenant.db.Statement.ConnPool = db.Statement.ConnPool
	r.Car.db = db.Session(&gorm.Session{Initialized: true})
	r.Car.db.Statement.ConnPool = db.Statement.ConnPool
	r.Renter.db = db.Session(&gorm.Session{Initialized: true})
	r.Renter.db.Statement.ConnPool = db.Statement.ConnPool
	return r
}

func (r rental) replaceDB(db *gorm.DB) rental {
	r.rentalDo.ReplaceDB(db)
	r.RentalOptions.db = db.Session(&gorm.Session{})
	r.Tenant.db = db.Session(&gorm.Session{})
	r.Car.db = db.Session(&gorm.Session{})
	r.Renter.db = db.Session(&gorm.Session{})
	return r
}

type rentalHasManyRentalOptions struct {
	db *gorm.DB

	field.RelationField

	Rental struct {
		field.RelationField
		Tenant struct {
			field.RelationField
			Cars struct {
				field.RelationField
				Tenant struct {
					field.RelationField
				}
				Rentals struct {
					field.RelationField
				}
			}
		}
		Car struct {
			field.RelationField
		}
		Renter struct {
			field.RelationField
			Rentals struct {
				field.RelationField
			}
		}
		RentalOptions struct {
			field.RelationField
		}
	}
	Option struct {
		field.RelationField
		RentalOptions struct {
			field.RelationField
		}
	}
}

func (a rentalHasManyRentalOptions) Where(conds ...field.Expr) *rentalHasManyRentalOptions {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a rentalHasManyRentalOptions) WithContext(ctx context.Context) *rentalHasManyRentalOptions {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a rentalHasManyRentalOptions) Session(session *gorm.Session) *rentalHasManyRentalOptions {
	a.db = a.db.Session(session)
	return &a
}

func (a rentalHasManyRentalOptions) Model(m *dbmodel.Rental) *rentalHasManyRentalOptionsTx {
	return &rentalHasManyRentalOptionsTx{a.db.Model(m).Association(a.Name())}
}

func (a rentalHasManyRentalOptions) Unscoped() *rentalHasManyRentalOptions {
	a.db = a.db.Unscoped()
	return &a
}

type rentalHasManyRentalOptionsTx struct{ tx *gorm.Association }

func (a rentalHasManyRentalOptionsTx) Find() (result []*dbmodel.RentalOption, err error) {
	return result, a.tx.Find(&result)
}

func (a rentalHasManyRentalOptionsTx) Append(values ...*dbmodel.RentalOption) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a rentalHasManyRentalOptionsTx) Replace(values ...*dbmodel.RentalOption) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a rentalHasManyRentalOptionsTx) Delete(values ...*dbmodel.RentalOption) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a rentalHasManyRentalOptionsTx) Clear() error {
	return a.tx.Clear()
}

func (a rentalHasManyRentalOptionsTx) Count() int64 {
	return a.tx.Count()
}

func (a rentalHasManyRentalOptionsTx) Unscoped() *rentalHasManyRentalOptionsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type rentalBelongsToTenant struct {
	db *gorm.DB

	field.RelationField
}

func (a rentalBelongsToTenant) Where(conds ...field.Expr) *rentalBelongsToTenant {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a rentalBelongsToTenant) WithContext(ctx context.Context) *rentalBelongsToTenant {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a rentalBelongsToTenant) Session(session *gorm.Session) *rentalBelongsToTenant {
	a.db = a.db.Session(session)
	return &a
}

func (a rentalBelongsToTenant) Model(m *dbmodel.Rental) *rentalBelongsToTenantTx {
	return &rentalBelongsToTenantTx{a.db.Model(m).Association(a.Name())}
}

func (a rentalBelongsToTenant) Unscoped() *rentalBelongsToTenant {
	a.db = a.db.Unscoped()
	return &a
}

type rentalBelongsToTenantTx struct{ tx *gorm.Association }

func (a rentalBelongsToTenantTx) Find() (result *dbmodel.Tenant, err error) {
	return result, a.tx.Find(&result)
}

func (a rentalBelongsToTenantTx) Append(values ...*dbmodel.Tenant) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a rentalBelongsToTenantTx) Replace(values ...*dbmodel.Tenant) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a rentalBelongsToTenantTx) Delete(values ...*dbmodel.Tenant) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a rentalBelongsToTenantTx) Clear() error {
	return a.tx.Clear()
}

func (a rentalBelongsToTenantTx) Count() int64 {
	return a.tx.Count()
}

func (a rentalBelongsToTenantTx) Unscoped() *rentalBelongsToTenantTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type rentalBelongsToCar struct {
	db *gorm.DB

	field.RelationField
}

func (a rentalBelongsToCar) Where(conds ...field.Expr) *rentalBelongsToCar {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a rentalBelongsToCar) WithContext(ctx context.Context) *rentalBelongsToCar {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a rentalBelongsToCar) Session(session *gorm.Session) *rentalBelongsToCar {
	a.db = a.db.Session(session)
	return &a
}

func (a rentalBelongsToCar) Model(m *dbmodel.Rental) *rentalBelongsToCarTx {
	return &rentalBelongsToCarTx{a.db.Model(m).Association(a.Name())}
}

func (a rentalBelongsToCar) Unscoped() *rentalBelongsToCar {
	a.db = a.db.Unscoped()
	return &a
}

type rentalBelongsToCarTx struct{ tx *gorm.Association }

func (a rentalBelongsToCarTx) Find() (result *dbmodel.Car, err error) {
	return result, a.tx.Find(&result)
}

func (a rentalBelongsToCarTx) Append(values ...*dbmodel.Car) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a rentalBelongsToCarTx) Replace(values ...*dbmodel.Car) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a rentalBelongsToCarTx) Delete(values ...*dbmodel.Car) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a rentalBelongsToCarTx) Clear() error {
	return a.tx.Clear()
}

func (a rentalBelongsToCarTx) Count() int64 {
	return a.tx.Count()
}

func (a rentalBelongsToCarTx) Unscoped() *rentalBelongsToCarTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type rentalBelongsToRenter struct {
	db *gorm.DB

	field.RelationField
}

func (a rentalBelongsToRenter) Where(conds ...field.Expr) *rentalBelongsToRenter {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a rentalBelongsToRenter) WithContext(ctx context.Context) *rentalBelongsToRenter {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a rentalBelongsToRenter) Session(session *gorm.Session) *rentalBelongsToRenter {
	a.db = a.db.Session(session)
	return &a
}

func (a rentalBelongsToRenter) Model(m *dbmodel.Rental) *rentalBelongsToRenterTx {
	return &rentalBelongsToRenterTx{a.db.Model(m).Association(a.Name())}
}

func (a rentalBelongsToRenter) Unscoped() *rentalBelongsToRenter {
	a.db = a.db.Unscoped()
	return &a
}

type rentalBelongsToRenterTx struct{ tx *gorm.Association }

func (a rentalBelongsToRenterTx) Find() (result *dbmodel.Renter, err error) {
	return result, a.tx.Find(&result)
}

func (a rentalBelongsToRenterTx) Append(values ...*dbmodel.Renter) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a rentalBelongsToRenterTx) Replace(values ...*dbmodel.Renter) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a rentalBelongsToRenterTx) Delete(values ...*dbmodel.Renter) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a rentalBelongsToRenterTx) Clear() error {
	return a.tx.Clear()
}

func (a rentalBelongsToRenterTx) Count() int64 {
	return a.tx.Count()
}

func (a rentalBelongsToRenterTx) Unscoped() *rentalBelongsToRenterTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type rentalDo struct{ gen.DO }

func (r rentalDo) Debug() *rentalDo {
	return r.withDO(r.DO.Debug())
}

func (r rentalDo) WithContext(ctx context.Context) *rentalDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r rentalDo) ReadDB() *rentalDo {
	return r.Clauses(dbresolver.Read)
}

func (r rentalDo) WriteDB() *rentalDo {
	return r.Clauses(dbresolver.Write)
}

func (r rentalDo) Session(config *gorm.Session) *rentalDo {
	return r.withDO(r.DO.Session(config))
}

func (r rentalDo) Clauses(conds ...clause.Expression) *rentalDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r rentalDo) Returning(value interface{}, columns ...string) *rentalDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r rentalDo) Not(conds ...gen.Condition) *rentalDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r rentalDo) Or(conds ...gen.Condition) *rentalDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r rentalDo) Select(conds ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r rentalDo) Where(conds ...gen.Condition) *rentalDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r rentalDo) Order(conds ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r rentalDo) Distinct(cols ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r rentalDo) Omit(cols ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r rentalDo) Join(table schema.Tabler, on ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r rentalDo) LeftJoin(table schema.Tabler, on ...field.Expr) *rentalDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r rentalDo) RightJoin(table schema.Tabler, on ...field.Expr) *rentalDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r rentalDo) Group(cols ...field.Expr) *rentalDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r rentalDo) Having(conds ...gen.Condition) *rentalDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r rentalDo) Limit(limit int) *rentalDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r rentalDo) Offset(offset int) *rentalDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r rentalDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *rentalDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r rentalDo) Unscoped() *rentalDo {
	return r.withDO(r.DO.Unscoped())
}

func (r rentalDo) Create(values ...*dbmodel.Rental) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r rentalDo) CreateInBatches(values []*dbmodel.Rental, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r rentalDo) Save(values ...*dbmodel.Rental) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r rentalDo) First() (*dbmodel.Rental, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*dbmodel.Rental), nil
	}
}

func (r rentalDo) Take() (*dbmodel.Rental, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*dbmodel.Rental), nil
	}
}

func (r rentalDo) Last() (*dbmodel.Rental, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*dbmodel.Rental), nil
	}
}

func (r rentalDo) Find() ([]*dbmodel.Rental, error) {
	result, err := r.DO.Find()
	return result.([]*dbmodel.Rental), err
}

func (r rentalDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*dbmodel.Rental, err error) {
	buf := make([]*dbmodel.Rental, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r rentalDo) FindInBatches(result *[]*dbmodel.Rental, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r rentalDo) Attrs(attrs ...field.AssignExpr) *rentalDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r rentalDo) Assign(attrs ...field.AssignExpr) *rentalDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r rentalDo) Joins(fields ...field.RelationField) *rentalDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r rentalDo) Preload(fields ...field.RelationField) *rentalDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r rentalDo) FirstOrInit() (*dbmodel.Rental, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*dbmodel.Rental), nil
	}
}

func (r rentalDo) FirstOrCreate() (*dbmodel.Rental, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*dbmodel.Rental), nil
	}
}

func (r rentalDo) FindByPage(offset int, limit int) (result []*dbmodel.Rental, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r rentalDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r rentalDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r rentalDo) Delete(models ...*dbmodel.Rental) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *rentalDo) withDO(do gen.Dao) *rentalDo {
	r.DO = *do.(*gen.DO)
	return r
}
