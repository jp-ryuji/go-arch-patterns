# Adding New Services

This document explains how to add new services to the car rental platform. The platform already includes a `Car` service as an example of the complete implementation. This guide will show you how to add additional services following the same patterns, using the existing `Car` service implementation as a reference.

## Overview

When adding new services to the platform, you need to follow several steps to ensure proper integration with the existing architecture. The process involves creating new Protocol Buffer definitions, implementing gRPC-Connect services, and updating the dependency injection container.

This guide references the existing `Car` service implementation as an example. You can follow the same patterns to implement new services. The `Car` service is fully implemented and can be found at:

- Protocol Buffers: `api/proto/car/v1/`
- Generated code: `api/generated/car/v1/`
- Domain layer: `internal/domain/entity/car.go`, `internal/domain/repository/car.go`
- Infrastructure layer: `internal/infrastructure/postgres/ent/schema/car.go`, `internal/infrastructure/postgres/repository/car_repository.go`
- Application layer: `internal/application/service/car_service.go`
- Presentation layer: `internal/presentation/connect/car/v1/service.go`

## Steps to Add a New Service

### 1. Define the Service in Protocol Buffers

Create new Protocol Buffer files in the `api/proto` directory:

1. Create a new directory for your service under `api/proto`, e.g., `api/proto/car/v1/`
2. Define your message types in a file like `car.proto`
3. Define your service methods in a file like `car_service.proto`

For reference, see the existing `Car` service definitions:

Example `api/proto/car/v1/car.proto`:

```protobuf
syntax = "proto3";

package car.v1;

option go_package = "github.com/jp-ryuji/go-arch-patterns/api/generated/car/v1;carv1";

import "google/protobuf/timestamp.proto";

message Car {
  string id = 1;
  string tenant_id = 2;
  string model = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}
```

Example `api/proto/car/v1/car_service.proto`:

```protobuf
syntax = "proto3";

package car.v1;

import "api/proto/car/v1/car.proto";

option go_package = "github.com/jp-ryuji/go-arch-patterns/api/generated/car/v1;carv1";

service CarService {
  rpc CreateCar(CreateCarRequest) returns (CreateCarResponse);
  rpc GetCar(GetCarRequest) returns (GetCarResponse);
  rpc ListCars(ListCarsRequest) returns (ListCarsResponse);
}

message CreateCarRequest {
  string tenant_id = 1;
  string model = 2;
}

message CreateCarResponse {
  Car car = 1;
}

message GetCarRequest {
  string id = 1;
}

message GetCarResponse {
  Car car = 1;
}

message ListCarsRequest {
  string tenant_id = 1;
  int32 page_size = 2;
  string page_token = 3;
}

message ListCarsResponse {
  repeated Car cars = 1;
  string next_page_token = 2;
}
```

### 2. Lint Protocol Buffer Definitions

Before generating code, it's recommended to lint your Protocol Buffer definitions to ensure they follow best practices:

```bash
make lint.proto
```

This will check your `.proto` files for any linting issues according to the [Buf linting rules](https://docs.buf.build/lint/rules).

### 3. Generate Code from Protocol Buffers

After defining your service, generate the Go code:

```bash
make gen.buf
```

This will generate the necessary Go files in `api/generated/car/v1/`.

### 4. Implement Domain Layer

Create the domain entities, repositories, and services:

1. Create entity in `internal/domain/entity/car.go`
2. Create repository interface in `internal/domain/repository/car.go`
3. Create any necessary value objects in `internal/domain/value/`

### 5. Implement Infrastructure Layer

Create the infrastructure implementations:

1. Create Ent schema in `internal/infrastructure/postgres/ent/schema/car.go`
2. Generate Ent code: `make gen.ent`
3. Create repository implementation in `internal/infrastructure/postgres/repository/car_repository.go`

### 6. Implement Application Layer

Create the application service in `internal/application/service/car_service.go`.

### 7. Implement Connect Service Handler

Create the Connect service implementation in `internal/presentation/connect/car/v1/service.go`.

The Connect service handler should implement the interface generated by the Connect plugin. For each RPC method in your service, you'll need to implement a corresponding method in your handler that:

1. Converts the Connect request to your application DTO
2. Calls your application service
3. Converts the application response to a Connect response

Example implementation:

```go
// CarServiceHandler implements the Connect service for car operations
type CarServiceHandler struct {
    carService service.CarService
}

// NewCarServiceHandler creates a new CarServiceHandler
func NewCarServiceHandler(carService service.CarService) *CarServiceHandler {
    return &CarServiceHandler{
        carService: carService,
    }
}

// CreateCar creates a new car
func (h *CarServiceHandler) CreateCar(ctx context.Context, req *connect.Request[carv1.CreateCarRequest]) (*connect.Response[carv1.CreateCarResponse], error) {
    // Convert Connect request to application DTO
    input := input.CreateCar{
        TenantID: req.Msg.GetTenantId(),
        Model:    req.Msg.GetModel(),
    }

    // Call application service
    carOutput, err := h.carService.Create(ctx, input)
    if err != nil {
        return nil, err
    }

    // Convert DTO to Connect response
    response := &carv1.CreateCarResponse{
        Car: &carv1.Car{
            Id:        carOutput.ID,
            TenantId:  carOutput.TenantID,
            Model:     carOutput.Model,
            CreatedAt: timestamppb.New(carOutput.CreatedAt),
        },
    }

    return connect.NewResponse(response), nil
}
// ... other methods
```

### 8. Update Dependency Injection Container

Update `internal/di/container.go` to include your new service:

```go
// Add new repository
carRepo := repository.NewCarRepository(client)

// Add to transaction manager if needed
// Update transaction manager constructor if needed

// Create application service
carService := service.NewCarService(carRepo, /* other dependencies */)

// Register Connect service handler
carServiceHandler := connectcar.NewCarServiceHandler(carService)
// The HTTP server will automatically register this handler
```

### 9. Update HTTP Server (if needed)

If your service needs custom HTTP handling, update `internal/presentation/http/server.go`.

The HTTP server automatically registers Connect handlers for your services. The Connect handler will be available at the RPC-style endpoint:

- `/car.v1.CarService/CreateCar` for the CreateCar RPC
- `/car.v1.CarService/GetCar` for the GetCar RPC
- `/car.v1.CarService/ListCars` for the ListCars RPC

### 10. Generate Mocks

Generate mocks for your new interfaces:

```bash
make gen.mocks
```

## Best Practices

1. **Follow Existing Patterns**: Look at how the car service is implemented as an example
2. **Use Proper Error Handling**: Follow the existing error handling patterns
3. **Implement Proper Logging**: Add logging where appropriate
4. **Write Tests**: Create unit tests for your new services
5. **Update Documentation**: Document your new service in the appropriate documentation files

## Testing Your New Service

1. **Unit Tests**: Write unit tests for your domain entities and services
2. **Integration Tests**: Write integration tests for your repository implementations
3. **API Tests**: Test your API endpoints manually or with automated tests
4. **End-to-End Tests**: Create end-to-end tests that exercise the full flow

## Example Checklist

When adding a new service, ensure you've completed these tasks:

- [ ] Protocol Buffer definitions created
- [ ] Protocol Buffer definitions linted
- [ ] Code generated from Protocol Buffers
- [ ] Domain entity created
- [ ] Repository interface defined
- [ ] Ent schema created
- [ ] Ent code generated
- [ ] Repository implementation created
- [ ] Application service created
- [ ] Connect service handler implemented
- [ ] Dependency injection container updated
- [ ] HTTP server updated (if needed)
- [ ] Mocks generated
- [ ] Unit tests written
- [ ] Integration tests written
- [ ] Documentation updated
